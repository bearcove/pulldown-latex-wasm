#!/usr/bin/env node

/**
 * Build and Package Script for Rust WebAssembly as an NPM Package
 *
 * This script automates the process of:
 * 1. Building a Rust project for WebAssembly with:
 *      cargo build --target wasm32-unknown-unknown --release
 * 2. Optimizing the generated WASM binary using wasm-opt (Binaryen)
 *      (using optimization level O3).
 * 3. Running wasm-bindgen CLI to generate JavaScript bindings, outputting
 *      the results into an `npm/` directory.
 * 4. Copying the project's package.json into the `npm/` subdirectory so that
 *      the final package is ready for publishing on npm.
 *
 * Requirements:
 * - Rust toolchain with Cargo installed.
 * - wasm-opt (from Binaryen) installed and in your PATH.
 * - wasm-bindgen CLI installed and in your PATH.
 * - A valid package.json file in the current working directory.
 *
 * Adjust the `projectName` variable below to match your Rust crate name.
 */

import { execSync } from "child_process";
import * as fs from "fs";
import * as path from "path";

// ----- Configuration -----
// Target triple for WASM builds (change if necessary).
const targetTriple = "wasm32-unknown-unknown";

// Name of your Rust crate (should match the .wasm file generated by Cargo).
const projectName = "pulldown_latex_wasm"; // <-- Update this to your crate's name

// Define paths.
const releaseDir = path.join("target", targetTriple, "release");
const wasmInputPath = path.join(releaseDir, `${projectName}.wasm`);
const optimizedWasmPath = path.join(releaseDir, `${projectName}.opt.wasm`);
const outDir = path.join("npm"); // Output directory for wasm-bindgen and package.json

// Helper function to run shell commands synchronously.
function runCommand(command, options = {}) {
  console.log(`Running: ${command}`);
  execSync(command, { stdio: "inherit", ...options });
}

try {
  // Step 0: Build/wipe out dir
  fs.rmSync(outDir, { recursive: true, force: true });
  fs.mkdirSync(outDir, { recursive: true });

  // Step 1: Build the Rust project.
  runCommand(`cargo build --target ${targetTriple} --release`);

  // Step 2: Optimize the WASM binary using wasm-opt.
  // This creates an optimized version of the .wasm file.
  runCommand(`wasm-opt -O3 -o ${optimizedWasmPath} ${wasmInputPath}`);

  // Step 3: Run wasm-bindgen to generate JavaScript bindings.
  // Here we use the "bundler" target; you can change this to "web" or "nodejs" as needed.
  runCommand(`wasm-bindgen --target bundler --out-dir ${outDir} --out-name ${projectName} ${optimizedWasmPath}`);

  // Step 4: Copy package.json into the output (npm/) directory.
  // Ensure the output directory exists.
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }

  const packageJsonSrc = path.join(process.cwd(), "package.json");
  const readmeSrc = path.join(process.cwd(), "README.md");
  const packageJsonDest = path.join(outDir, "package.json");
  const readmeDest = path.join(outDir, "README.md");

  if (fs.existsSync(packageJsonSrc)) {
    fs.copyFileSync(packageJsonSrc, packageJsonDest);
    console.log(`Copied package.json to ${packageJsonDest}`);
  } else {
    console.warn(`Warning: package.json not found at ${packageJsonSrc}`);
  }

  if (fs.existsSync(readmeSrc)) {
    fs.copyFileSync(readmeSrc, readmeDest);
    console.log(`Copied README.md to ${readmeDest}`);
  } else {
    console.warn(`Warning: README.md not found at ${readmeSrc}`);
  }

  console.log("Build and packaging process completed successfully.");
} catch (error) {
  console.error("An error occurred during the build process:");
  console.error(error);
  process.exit(1);
}
